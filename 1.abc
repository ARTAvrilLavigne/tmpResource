后台三部分处理：
1、ER
2、IR   避免大规模接口变更，通过请求头传递方式，在接口调用模板代码中置入cookie信息
3、数据库的处理

标准：IR接口不返回国际化资源，IR返回错误码，ER中拼接好key，前台做国际化


=========================================================================
框架组多语言总结：多语种支持需求
逆变器领域-数据修正、告警修正、电站管理、设备管理、适配层管理、设备接入、设备升级管理
数据中心领域-历史数据补采、监控模板设置、告警设置、信号管理

1、平台多语言支持方案：搭建国际化微服务，各个微服务要在 appdefine.json 中订阅国际化微服务中
本微服务语言包的 pub 事件。各微服务会通过 pub 获取页面展示所需的国际化资源文件，并且平台的
febs等微服务也会pub 获取菜单和角色权限的国际化资源

2、前台方案：React技术栈使用Json格式国际化资源，通过页面请求静态js资源，并加载到浏览器内存

3、后台方案：微服务从固定路径全量加载到内存，
	ER接口原则上后台返回数据均为国际化之后的值，不返回国际化key：避免国际化资源存在跨服务依赖
	IR接口原则上跨服务IR接口，如果返回信息中包含需要做国际化的信息，接口入参应该提供所需语种，
		返回信息时，优先通过指定语种返回，没有则返回默认语种
怎么避免接口大规模变更？
答：Restful Client 统一做切面，把语言放到HttpContextHead中

从用户ER接口调用上下文获取前台cookie中的语言信息
前台发起的http请求中，会携带cookie中的当前用户选择的语言与区域信息，通过Servlet的WebFilter时，
会将当前请求的请求头放置到线程上下文中，因此可以在后台接口实现中从cookie中解析出对应的语言与区域信息。


调用IR接口前，将ER接口中的请求头放置到调用IR的线程上下文
当前调用IR线程上下文即ER上下文，无需处理
另起新线程调用IR接口，在新线程中置入用户请求头，封装的通用方法：
    com.huawei.neteco.plat.sm.WebContext#prepareOrRefresh
    线程任务退出前调用清理方法清理线程上下文：
    com.huawei.neteco.plat.sm.WebContext#invalidate
涉及init()、缓存、事件、新线程、IR调用特殊处理

4、接入包的多语言支持方案：接入包支持增量语言包，资源持久化，从数据库加载
==========================================================================
国际化微服务框架与语言包制作、业务层面功能模块多语种支持、基础模型底层数据接口整改、
平台小语种能力适配--17人月
=========================================================================


底层改造：
主要任务是标准模型、接入模型支持多语种资源信息入库及缓存；
标准模型、接入模型、实例元数据支持按需获取语种资源；支持解析适配层接入包中多语言资源信息等
=============
标准模型：
标准模型缓存类：MOCCache
标准模型资源文件主要定义于NetEcoCoreService的部署文件夹下以及用户操作自定义的标准信号存在数据库，
构建MOCCache初始化缓存时，加载core中xml配置文件到缓存以及数据库中标准模型到缓存

标准模型语言资源扩展表及其多语种资源入库，将标准模型资源表的lan_type字段修改为lan_tag，类型
由tinyint变为varchar，标准模型资源表(做分区partition)存储中英文资源，扩展表存储其它语系资源

标准模型基础对象为MOC对象，标准模型各信号对象有：DefaultMOCAlarmSignal、DefaultMOCConfigSignal、
DefaultMOCSamplingSignal、DefaultMOCStatisticSignal
=============
接入模型：
接入模型新增其余语种时时，由MedService解析接入包后传来入参，在此先不详解，只说其中一个关键点在于
资源容器由Map<LanguageType, Map<Long, String>>变更为Map<String, Map<Long, String>>，
后者的外层map的key为Locale的languageTag。入库入缓存

将接入模型资源表的lan_type字段修改为lan_tag，类型由tinyint变为varchar，接入模型资源表存储中英文资源，
扩展表(做分区partition)存储其它语系资源。

接入模型的缓存由MOTypeCache处理，其中LanguageResourceCache为接入模型的多语种资源统一处理缓存，
其实现了加锁及懒加载

MOTypeCache中cacheEntity存储的就是DefaultMOType接入模型对象

LanguageResourceCache就是用于locale接口传入后使用它进行查询得到该语种的资源信息，LanguageResourceCache
存储的多语种资源结构：包括map<Locale, map<motype_primaryId, map<resId, res_value>>>,
初始化时按照系统语言类型查询多语种资源后放入该缓存，传入locale查询是如果该语系已有直接返回，
如果没有就从数据库里查询一次全量加载放到缓存中。

针对接入模型用户自定义元数据MOTypeOverrideCache：
用户自定义元数据缓存容器初始化：数据库查询用户自定义元数据信息，然后放入缓存
结构：包含各个信号单独存储自定义元数据,如采样map<Integer,map<samplingSignalMetadata, obj>>samplingSignals
查询：取值按照自定义元数据的信号类型取值，还会传入对应信号类型的元数据类型将存储在数据库中的值解析为
该元数据类型的新值否则置为信号自带的配置值



========================
接入模型解耦原理：
接入模型解耦主要是接入模型的告警信号、配置信号、采集信号、统计信号的解耦，原来系统不用支持多语种，
所以原先接入模型信号对象属性值存储的是与标准模型信号、用户修改的元数据进行覆盖后的值，为了支持多
语种，现在缓存存储的接入模型各信号对象只存储该信号本身的信息，解除耦合，最后的装配移到网元模型信号
中去实现。本文以接入模型采集信号为例，因为采集信号涉及方面最广。

接入模型信号对象，如采集信号：samplingSignal，具体实现上实际为BasicSamplingSignal


=========================
网元模型信号：
网元模型信号对象，如采集：MOSamplingSignal，它包含了接入模型的采集信号samplingSignal(BasicSamplingSignal)和
标准模型的采集信号mocSamplingSignal

查询时首先用标准信号mocSamplingSignal.name(locale)，若mocSamplingSignal为null才用接入信号
amplingSignal.name(locale)
